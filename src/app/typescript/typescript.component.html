<h2>TypeScript Introduction:</h2>
<div>
    <p>TypeScript is an Open-Source-Project from Microsoft. It expands JavaScript, so you can also write as much
        JavaScript as you want in your TypeScript document.
    </p>
    <p>But it comes with a much stronger type system, as you may know from programming languages like Java and C#.</p>
    <p>Bonus: TypeScript compiles to pure JavaScript and therefor it's runable in every browser and platform.</p>

    <h4>1. Basictypes</h4>
    <p>When you declare and initialize a variable, it's always the same:</p>
    <p class="ui info message"><code>name: type = value;</code></p>

    <h5>number</h5>
    <p><code>age: number = 5;</code></p>
    <h5>String</h5>
    <p><code>firstname: String = 'Michaela';</code></p>
    <p>Template-String: Expressions embedded directly in the string.</p>
    <p><code>output: String = `&#123;firstname&#125; is &#123;age&#125; years old.`;</code></p>

    <h5>var</h5>
    <p>Variables with var are just valid in the function you declared them.</p>
    <h5>let</h5>
    <p>It is for block-bound variables only, they are just valid for the specific control structure, not
        for the whole function. E.g. just valid in a control structure such as a for-loop.</p>
    <h5>const</h5>
    <p>Once initialized you can't overwrite the value. They always have to be initialized.</p>

    <h5>Getter and Setter</h5>
    <p>
        Known from object oriented programing. You can read or set the property of an object.
    </p>
    <h5>Boolean</h5>
    <p><code>let workingHard: Boolean = ‚true‘;</code></p>
    <h5>Arrays</h5>
    <p><code>let fibonacci: Array&lt;number&gt;  = [0, 1, 1, 2, 3, 5, 8, 13];</code></p>
    <p><code>let fibonacci: number[] =[0, 1, 1, 2, 3, 5, 8, 13];</code></p>
    <p><code>let differentValueTypes = [ 5, &#123; firstname: 'Michaela' &#125;, function() &#123; console.warn(‚Nothing inside.‘) &#125; ];</code></p>
    <h5>Spread-Operator</h5>
    <p><code>var arr1 = [ 1, 2, 5];</code></p>
    <p><code>var arr2 = [ ...arr1, 7, 8,];</code></p>
    <p>Numbers in arr2 are now: <code>[ 1, 2, 5, 7, 8]</code></p>
    <h5>Any</h5>
    <p> You can always use the fallback value "any", if you do not know which data type you will get back.</p>

    <h4>2. Classes</h4>
    <p><code>class Animal &#123; &#125; </code></p>
    <h5>Properties</h5>
    <p>Extend classes with further information. An animal could have name, age and owner.</p>
    <p><code>class Animal &#123; <br />&nbsp;&nbsp;public name: String; <br />&nbsp;&nbsp;public age: number; <br />&nbsp;&nbsp;public owner: String; <br />&#125;</code></p>

    <h5>Methods</h5>
    <p>Extend classes with logic. In addition TypeScript allows it to precise the signature of the methods with a
        parameter type and a return type. </p>
    <p><code>class Animal &#123; <br />&nbsp;&nbsp;public name: String; <br />&nbsp;&nbsp;public age: number; <br />&nbsp;&nbsp;public owner: String; <br />&nbsp;&nbsp;changeOwner(owner: String): String&#123;<br />&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner; <br />&nbsp;&nbsp;&nbsp;&nbsp;return this.owner; <br />&nbsp;&nbsp;&#125;<br />&#125;</code></p>
    <p>If you use void as return type, the method has no return value.</p>
    <h5>Constructors</h5>
    <p>Constructors are methods which are called during initializing a class. Values can be transferred that are
        necessary later.</p>
    <p><code>constructor( name: String; age: number; owner: String;) &#123; 
        <br />&nbsp;&nbsp;this.name = name;
        <br />&nbsp;&nbsp;this.age = age;
        <br />&nbsp;&nbsp;this.owner = owner; <br />&#125;</code></p>
    <p>A difference to other programing languages: per class is just ONE constructor possible!</p>

    <h5>Inheritance</h5>
    <p>Also known from object oriented programing, with the keyword <code>extends</code>.</p>
    <p><code>class Cat extends Animal &#123; &#125; </code></p>
    <p>You can use the methods and constructors of the basis class with <code>super()</code>. The methods can be
        rewritten. If a derived class (Cat) is instantiated, you automatically get access to attributes and methods of
        the parent classes (Animal). </p>

    <h4>4. Interfaces</h4>
    <p>Interfaces are used to define a public interface and hide the concrete implementation. It can be determined
        which parts must be included and which types they should have.</p>
    <p>Optional parameters have a <code>?</code> behind their name. E.g. <code>public owner?: String;</code></p>
    <p><code>interface Contact = &#123; firstname: String; lastname: String; age?: number | String &#125;</code></p>
    <p>If the object gets an additional property or the value does not have the required type you would get an error.</p>

    <h5>Indexable Interfaces</h5>
    <p>Interfaces can also be defined via an indexable key. E.g. interface determines the type for all elements of an
        array.</p>
    <p><code>interface StringArray &#123; [index: number]: string; &#125;</code></p>

    <h5>Interfaces for Functions</h5>
    <p>The key is the function signature. The value of the interface is the return value of the function.</p>

    <h5>Interface for Classes</h5>
    <p>The keyword to implement an Interface is <code>implements</code>. The compiler will indicate that the
        implementation of the interface required. That means, all defined properties and methods of the interface. Type
        definitions are the same like in the interface.</p>

    <h4>5. Decorators</h4>
    <p><code>
            @Component(&#123; <br/>// configuration object <br/>&#125;)<br/>
            class myComponent &#123; &#125;
              
    </code></p>
    <p>Metadata is added to the class. The Angular-Framework knows that the class is to handle as a component</p>
    <p>Expressions such as <code>@readonly</code> are not provided in Angular.</p>
</div>

<div class="ui message" style="margin-top: 30px; margin-bottom: 30px;">
    <p>Now that you know all these things, you are ready for a bigger project. Feel free to come back any time, if you
    want to look up something.</p>
</div>